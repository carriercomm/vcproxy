#!/usr/bin/python
#
# FLV capture based on Jonas Wagner's HTTPRipper

import os, sys, re
import prox
from datetime import datetime
from Queue import Queue, Empty
import logging
import threading
import warcwriter
from cStringIO import StringIO

class Tee(object):
    """A filelike that writes it's data to two others"""
    def __init__(self, f1, f2):
        self.f1 = f1
        self.f2 = f2

    def write(self, data):
        self.f1.write(data)
        self.f2.write(data)

def capture(url):
    m = re.match(r'http://proxy.api.video.yahoo.com/videoAPI/.*/Video\.([a-zA-Z0-9]+)\?.*\&ID=(\d+)', url)
    if m:
        return (m.group(2), m.group(1))
    m = re.match(r'http://video.yahoo.com/ws/.*', url)
    if m:
        return ()
        
class Capture(object):
    '''A file-like that writes incoming data to both file-like given
    and WarcWriter, doing buffering when content-length is unknown.'''
    def __init__(self, f1, start, headers, clen, compresslevel,
                 **kwds):
        self.f1 = f1
        self.start_record = start
        self.clen = clen
        if self.clen is None:
            self.w = StringIO()
            self.headers = headers
            self.compresslevel = compresslevel
            self.kwds = kwds
        else:
            self.w = self.start_record(headers, clen, compresslevel, **kwds)
            
    def write(self, data):
        self.f1.write(data)
        self.w.write(data)
        
    def close(self):
        if self.clen is None:
            data = self.w.getvalue()
            w = self.start_record(self.headers, len(data), self.compresslevel,
                                  **self.kwds)
            w.write(data)
            w.close()
        self.w.close()
        
class HTTPProxyHandler(prox.HTTPProxyHandler):
    def get_writer(self):
        ww = getattr(self, 'ww', None)
        if ww is None: ww = self.ww = self.server.get_writer()
        return ww
    def put_writer(self):
        ww = getattr(self, 'ww', None)
        if ww:
            ww.check_size()
            self.server.put_writer(ww)
            self.ww = None
        
    def forward_request_body(self, f1, f2, contentlength):
        save, clv = self.server.should_save(
            True, self.url, self.requestheaders)
        if save:
            ww = self.get_writer()
            f2 = Capture(f2, ww.start_request, self.requestheaders,
                         contentlength, compresslevel=clv,
                         uri=self.url)
        else: ww = None
        self.forward(f1, f2, contentlength)
        if ww: f2.close()
        
    def forward_response_body(self, f1, f2, contentlength):
        '''forwards the content to the client and saves video streams in
        level-0 compression WARC file'''
        try:
            save, clv = self.server.should_save(
                False, self.url, self.responseheaders)
            if save:
                ww = self.get_writer()
                f2 = Capture(f2, ww.start_response, self.responseheaders,
                             contentlength, compresslevel=clv,
                             uri=self.url)
            else: self.put_writer(); ww = None
            self.forward(f1, f2, contentlength)
            if ww: f2.close()
        finally:
            self.put_writer()

class HTTPProxyServer(prox.HTTPProxyServer):
    def __init__(self, prefix='res'):
        prox.HTTPProxyServer.__init__(self, ("0.0.0.0", 8080),
                                      HTTPProxyHandler)
        self.prefix = prefix
        self.writers_lock = threading.RLock()
        self.writers = []
        self.writers_queue = Queue()

    def get_writer(self):
        # wait 50ms
        try:
            return self.writers_queue.get(True, 0.05)
        except Empty:
            with self.writers_lock:
                w = warcwriter.open('%s-%s-%04d' % (self.prefix, os.getpid(),
                                                    len(self.writers)))
                self.writers.append(w)
                return w
    def put_writer(self, w):
        self.writers_queue.put(w)

    def close_writers(self):
        for w in self.writers:
            w.close()

    # TODO: Y!V specific. make this configurable with XML or something.
    def should_save(self, request, url, headers):
        ct = headers.get('Content-Type', [''])[0]
        if request:
            if re.match(r'http://video\.yahoo\.com/watch/\d+/\d+', url):
                return (True, 9)
        else:
            if ct.startswith('video/flash'):
                return (True, 0)
            if re.match(r'http://.*\.yahoo\.com/videoAPI/', url):
                return (True, 9)
        return (False, 0)

if __name__ == '__main__':
    from optparse import OptionParser
    op = OptionParser()
    op.add_option('-p', '--prefix', action='store', dest='prefix',
                  help='prefix (first string before "-PID-THREAD-...") '
                  'for warc file name (default "VC")', default='VC')
    op.add_option('-v', '--verbose', action='store_const', dest='loglevel',
                  const=logging.DEBUG,
                  default=logging.ERROR,
                  help='enables DEBUG-level logging (default ERROR)')
    
    options, args = op.parse_args()

    logging.basicConfig(level=options.loglevel)

    server = HTTPProxyServer(prefix=options.prefix)
    try:
        server.serve_forever()
    finally:
        server.close_writers()

